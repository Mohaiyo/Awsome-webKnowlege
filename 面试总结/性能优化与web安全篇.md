一，性能优化

(一) 前端优化：

1，资源加载(阻塞):

   (1)，问题：同步加载js引发阻塞。
   
   (2)，优化：底部加载、异步加载。  
   
      动态创建script标签；
      
      给script标签添加async或defer属性，实现异步加载。
   
   (3)，原理：  
   
      加载js时会阻塞dom渲染,因此需要放底部等待dom结构渲染结束后再加载js；  
     
      另一种思路是异步加载，即加载js的同时不影响dom渲染。
   
 2，DOM渲染    

   （1）构成：初始化渲染、DOM更新。
    
   （2）问题：渲染量大，渲染频繁，造成渲染时间过长。
   
   （3）优化：使用react、vue等高性能框架，减少渲染次数和渲染量。
   
   （4）原理：   
   
      1) react通过diff算法和虚拟DOM，将大部分的DOM处理都在虚拟DOM中完成。  
       
      2) 然后通过innerHTML属性一次性地把整个dom树局部地渲染出来。
         
         
  3，HTTP请求  
  
  
    (1) 静态资源请求  
    
        静态资源有html、css、js、img、file等等。
      
       1) 问题: 资源过大、过多，造成请求时间过长。
       
       2) 优化：  
       
         通过webpack、gulp等构建工具对静态资源进行合并、压缩、拆分等手段，  
         
         达到减小资源体积、减少资源数量，从而使请求时间最小化。
    
       3) 原理：
       
         请求的资源体积小，数量少，那么请求的时间就短，能加快客户端响应。
      
     (2) api请求
     
       统一接口规范；
       
       避免无响应的情况发生；
   
   
   3，延迟加载   
    
       问题： 
       
         通常首页内容很多，模块很多，但可视区(屏幕窗口)展示的并不是首页的所有内容。   
         
         这就造成了加载浪费的问题。
         
       优化：
       
         根据用户浏览时当前可视区的所在的模块，请求该模块相应的数据。
         
         根据用户浏览的需要来按需加载。而不是一次性全部加载出来。
    
    4，静态缓存   
    
       使用redis做数据缓存；
       
       使用nginx做资源缓存；
       
       使用H5的application cache做应用程序缓存。
    
(二) 后端优化：

 1，服务端渲染：  
 
   能加快首屏渲染的速度，以及对SEO的友好支持。
  
 2，使用nginx部署前端代码，开启gizp压缩。  
 
 
(三) 系统性优化：

 1，加大服务器带宽和内存。
 
 2，使用cdn存储静态资源，开启cdn加速。

二，web安全

1，xss漏洞(cross-site script)

  攻击者在输入域注入恶意代码，注入的代码会被执行，从而达到攻击的特殊目的。
 
预防：输入输出检查，对特殊字符进行转义。
2，csrf跨站请求伪造( cross-site request Forgey)


预防：  

  验证码:  防止恶意登录注册
  
  token验证: 登录后生成密钥随cookie返回客户端，后续前端请求需要提供这个密钥。

React 默认会转义所有字符